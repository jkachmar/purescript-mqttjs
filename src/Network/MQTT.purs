module Network.MQTT
  ( module Network.MQTT
  , module Exports
  ) where

import Control.Bind (bind)
import Control.Monad.Eff (Eff, kind Effect)
import Control.Monad.Eff.Uncurried (EffFn1, EffFn2, EffFn3, mkEffFn1, mkEffFn2, runEffFn1, runEffFn2, runEffFn3)
import Control.Semigroupoid ((<<<))
import Data.Foreign (Foreign)
import Data.Function (($))
import Data.Newtype (class Newtype, unwrap)
import Data.Unit (Unit)
import Network.MQTT.Internal (Message(..), Topic(..)) as Exports
import Network.MQTT.Internal (Message, Topic, unsafeReadMessage, unsafeReadTopic)
import Node.Buffer (BUFFER)

--------------------------------------------------------------------------------
-- | Effects generated by the MQTT client.
foreign import data MQTT :: Effect

-- | A JavaScript MQTT client.
foreign import data Client :: Type

--------------------------------------------------------------------------------
-- | The MQTT broker URL.
newtype BrokerUrl = BrokerUrl String
derive instance ntBrokerUrl :: Newtype BrokerUrl _

-- TODO - all the options that the original library can take should be
-- represented here, and `connect` should use a `Options -> Foreign` function
-- to cull the optional values before sending to the FFI.
-- | The MQTT client connection options.
type Options =
  { port     :: Int
  , clientId :: String
  , username :: String
  , password :: String
  }

--------------------------------------------------------------------------------
foreign import _connect :: ∀ e.
  EffFn2 (mqtt :: MQTT | e)
    String
    Options
    Client

-- | Attempt to connect to some MQTT broker at the given `BrokerUrl` using the
-- | supplied connection `Options`, returning a `Client` with an active
-- | connection.
connect :: ∀ e. BrokerUrl -> Options -> Eff (mqtt :: MQTT | e) Client
connect url options = runEffFn2 _connect (unwrap url) options

--------------------------------------------------------------------------------
foreign import _end :: ∀ e.
  EffFn1 (mqtt :: MQTT | e)
    Client
    Unit

-- | Closes a `Client`'s connection to the MQTT broker. Note that this causes
-- | the `Client` to emit a `'close'` event, which emits an `OnClose` in any
-- | `Producer`s spawned from this client, ending the coroutine.
end :: ∀ e. Client -> Eff (mqtt :: MQTT | e) Unit
end = runEffFn1 _end

--------------------------------------------------------------------------------
foreign import _subscribe :: ∀ e.
  EffFn2 (mqtt :: MQTT | e)
    Client
    String
    Unit

-- | Subscribes to a `Topic`. Note that this causes the `Client` to emit a
-- | `'message'` event for any `Message`s received on the `Topic`, which emits
-- | an `OnMessage` in any `Producer`s spawned from this client, containing
-- | both the `Message` received and the `Topic` it was sent from.
subscribe :: ∀ e. Client -> Topic -> Eff (mqtt :: MQTT | e) Unit
subscribe client topic = runEffFn2 _subscribe client (unwrap topic)

--------------------------------------------------------------------------------
foreign import _publish :: ∀ e.
  EffFn3 (mqtt :: MQTT | e)
    Client
    String
    String
    Unit

-- | Publishes a `Message` to a `Topic`.
publish :: ∀ e. Client -> Topic -> Message -> Eff (mqtt :: MQTT | e) Unit
publish client topic message =
  runEffFn3 _publish client (unwrap topic) (unwrap message)

--------------------------------------------------------------------------------
foreign import _onConnect :: ∀ e.
  EffFn2 (mqtt :: MQTT | e)
    Client
    (EffFn1 (mqtt :: MQTT| e) Unit Unit)
    Unit

-- | Registers a callback to handle `'connect'` events emitted by the `Client`.
-- | This is useful when using the library to create event handlers as in
-- | `Network.MQTT.Coroutine`.
onConnect
  :: ∀ e
   . Client
  -> (Unit -> Eff (mqtt :: MQTT | e) Unit)
  -> Eff (mqtt :: MQTT | e) Unit
onConnect client = runEffFn2 _onConnect client <<< mkEffFn1

--------------------------------------------------------------------------------
foreign import _onMessage :: ∀ e.
  EffFn2 (mqtt :: MQTT | e)
    Client
    (EffFn2 (mqtt :: MQTT | e) Foreign Foreign Unit)
    Unit

-- | Registers a callback to handle `'message'` events emitted by the `Client`.
-- | This is useful when using the library to create event handlers as in
-- | `Network.MQTT.Coroutine`.
onMessage
  :: ∀ e
   . Client
  -> (Topic -> Message -> Eff (buffer :: BUFFER, mqtt :: MQTT | e) Unit)
  -> Eff (buffer :: BUFFER, mqtt :: MQTT | e) Unit
onMessage client handler =
  let handler' t m = do
        let topic = unsafeReadTopic t
        message <- unsafeReadMessage m
        handler topic message
  in runEffFn2 _onMessage client $ mkEffFn2 handler'

--------------------------------------------------------------------------------
foreign import _onClose :: ∀ e.
  EffFn2 (mqtt :: MQTT | e)
    Client
    (EffFn1 (mqtt :: MQTT | e) Unit Unit)
    Unit

-- | Registers a callback to handle `'close'` events emitted by the `Client`.
-- | This is useful when using the library to create event handlers as in
-- | `Network.MQTT.Coroutine`.
onClose
  :: ∀ e
   . Client
  -> (Unit -> Eff (mqtt :: MQTT | e) Unit)
  -> Eff (mqtt :: MQTT | e) Unit
onClose client = runEffFn2 _onClose client <<< mkEffFn1
