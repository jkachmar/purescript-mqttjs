module Network.MQTT
  ( module Network.MQTT
  , module Exports
  ) where

-- import Prelude

import Control.Bind (bind, discard)
import Control.Coroutine (Consumer, Producer)
import Control.Coroutine.Aff (produce)
import Control.Monad.Aff (Aff)
import Control.Monad.Aff.AVar (AVAR)
import Control.Monad.Eff (Eff, kind Effect)
import Control.Monad.Eff.Uncurried (EffFn1, EffFn2, EffFn3, runEffFn1, runEffFn2, runEffFn3)
import Data.Either (Either(..))
import Data.Foreign (Foreign)
import Data.Function (($))
import Data.Newtype (class Newtype, unwrap)
import Data.Unit (Unit, unit)
import Network.MQTT.Internal (Message(..), Topic(..)) as Exports
import Network.MQTT.Internal (Message, Topic, unsafeReadMessage, unsafeReadTopic)
import Node.Buffer (BUFFER)

--------------------------------------------------------------------------------
-- | The MQTT broker URL.
newtype BrokerUrl = BrokerUrl String
derive instance ntBrokerUrl :: Newtype BrokerUrl _

-- | The MQTT client connection options.
type Options =
  { port     :: Int
  , clientId :: String
  , username :: String
  , password :: String
  }

--------------------------------------------------------------------------------
data MQTTEvent
  = OnConnect
  | OnMessage Topic Message
  | OnClose

--------------------------------------------------------------------------------
-- | Effects generated by the MQTT client.
foreign import data MQTT :: Effect

-- | A JavaScript MQTT client.
foreign import data Client :: Type

--------------------------------------------------------------------------------
foreign import _end :: ∀ e.
  EffFn1 (mqtt :: MQTT | e)
    Client
    Unit

-- | Ends the `Client`'s session.
end :: ∀ e. Client -> Eff (mqtt :: MQTT | e) Unit
end = runEffFn1 _end

--------------------------------------------------------------------------------
foreign import _connect :: ∀ e.
  EffFn2 (mqtt :: MQTT | e)
    String
    Options
    Client

connect :: ∀ e. BrokerUrl -> Options -> Eff (mqtt :: MQTT | e) Client
connect url options = runEffFn2 _connect (unwrap url) options

--------------------------------------------------------------------------------
foreign import _subscribe :: ∀ e.
  EffFn2 (mqtt :: MQTT | e)
    Client
    String
    Unit

subscribe :: ∀ e. Client -> Topic -> Eff (mqtt :: MQTT | e) Unit
subscribe client topic = runEffFn2 _subscribe client (unwrap topic)

foreign import _publish :: ∀ e.
  EffFn3 (mqtt :: MQTT | e)
    Client
    String
    String
    Unit

publish :: ∀ e. Client -> Topic -> Message -> Eff (mqtt :: MQTT | e) Unit
publish client topic message =
  runEffFn3 _publish client (unwrap topic) (unwrap message)

--------------------------------------------------------------------------------
type MQTTProducer e a =
  Producer MQTTEvent (Aff (avar :: AVAR, buffer :: BUFFER, mqtt :: MQTT | e)) a

type MQTTConsumer e a =
  Consumer MQTTEvent (Aff e) a

--------------------------------------------------------------------------------
mkMQTTProducer :: ∀ e. Client -> MQTTProducer e Unit
mkMQTTProducer client =
  produce \emit -> do
    runEffFn2 onConnect client \_ ->
      emit $ Left OnConnect

    runEffFn2 onMessage client \t m -> do
      let topic = unsafeReadTopic t
      message <- unsafeReadMessage m
      emit $ Left $ OnMessage topic message

    runEffFn2 onClose client \_ -> do
      emit $ Left $ OnClose
      emit $ Right unit

--------------------------------------------------------------------------------
foreign import onConnect :: ∀ e.
  EffFn2 (mqtt :: MQTT | e)
    Client
    (Unit -> Eff (mqtt :: MQTT | e) Unit)
    Unit

foreign import onMessage :: ∀ e.
  EffFn2 (mqtt :: MQTT | e)
    Client
    (Foreign -> Foreign -> Eff (mqtt :: MQTT | e) Unit)
    Unit

foreign import onClose :: ∀ e.
  EffFn2 (mqtt :: MQTT | e)
    Client
    (Unit -> Eff (mqtt :: MQTT | e) Unit)
    Unit
